<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>è¼ªèƒè‹±é›„ - æ¨‚å¯Œè‡ªè¡Œè»Šé–‹ç™¼</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: "Microsoft JhengHei", sans-serif; touch-action: none; user-select: none; }
        canvas { display: block; background: #87CEEB; }
        #ui {
            position: absolute; top: env(safe-area-inset-top, 20px); left: 20px; 
            color: #000; font-weight: 900; font-size: 26px;
            text-shadow: 2px 2px 0 #fff; pointer-events: none; z-index: 100;
        }
        #brand {
            position: absolute; bottom: 15px; left: 15px; 
            color: #000; font-weight: bold; font-size: 14px;
            text-shadow: 1px 1px 0 #fff; z-index: 100;
        }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 200;
        }
        #msg-box {
            background: #fff; color: #333; padding: 25px; border: 4px solid #000;
            border-radius: 15px; text-align: center; width: 300px;
        }
        .btn {
            display: inline-block; margin-top: 15px; padding: 12px 25px;
            background: #ff0000; color: #fff; border-radius: 50px;
            font-weight: bold; font-size: 20px; cursor: pointer;
        }
    </style>
</head>
<body onpointerdown="handleAction(event)">

<div id="ui">
    <div>åˆ†æ•¸: <span id="score">0</span></div>
    <div style="font-size: 16px;">æœ€é«˜ç´€éŒ„: <span id="highScore">0</span></div>
</div>
<div id="brand">æ¨‚å¯Œè‡ªè¡Œè»Šé–‹ç™¼</div>

<div id="overlay">
    <div id="msg-box">
        <h2 style="margin:0">è¼ªèƒè‹±é›„</h2>
        <p style="font-size:14px; color: red; font-weight: bold;">âš ï¸ æ³¨æ„ï¼šæƒ¡éœ¸çŠ¬å¼·è¥²ï¼(å«å å«)</p>
        <div class="btn">é–‹å§‹æŒ‘æˆ°</div>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const highScoreEl = document.getElementById('highScore');
const overlay = document.getElementById('overlay');

let gameState = 'START'; 
let score = 0;
let highScore = localStorage.getItem('bicycleHighScore') || 0;
highScoreEl.innerText = highScore;

let player = { x: 60, y: 0, w: 50, h: 50, vy: 0, jumped: false };
let obstacles = [];
let coins = [];
let bgX = 0;
let lastObstacleX = 0;

let audioCtx = null;
let bgmSequence = 0;
let bgmTimer = null;

function initAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playNote(freq, dur, type = 'square', vol = 0.04) {
    if(!audioCtx || gameState !== 'PLAYING') return;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    g.gain.setValueAtTime(vol, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
    osc.connect(g).connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + dur);
}

function playMarioBGM() {
    if (gameState !== 'PLAYING') return;
    const melody = [330, 330, 0, 330, 0, 262, 330, 0, 392, 0, 0, 0, 196, 0, 0, 0];
    let note = melody[bgmSequence % melody.length];
    if(note > 0) playNote(note, 0.1, 'square');
    if(bgmSequence % 4 === 0) playNote(165, 0.15, 'triangle', 0.06);
    bgmSequence++;
    bgmTimer = setTimeout(playMarioBGM, 150);
}

function barkEffect() {
    if(!audioCtx) return;
    playSfx(160, 'sawtooth', 0.12, false, 0.2);
    setTimeout(() => playSfx(140, 'sawtooth', 0.18, false, 0.2), 120);
}

function playSfx(freq, type, dur, slide = false, vol = 0.08) {
    if(!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    if(slide) osc.frequency.exponentialRampToValueAtTime(freq/5, audioCtx.currentTime + dur);
    g.gain.setValueAtTime(vol, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
    osc.connect(g).connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + dur);
}

// ç¹ªè£½åƒç…§åœ–é¢¨æ ¼æƒ¡éœ¸çŠ¬
function drawBullyDog(x, y, size) {
    ctx.save();
    ctx.translate(x, y);
    
    // è€³æœµ (ç«‹é«”å°–è€³)
    ctx.fillStyle = '#4A2B11';
    ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
    // å·¦è€³
    ctx.beginPath();
    ctx.moveTo(size*0.1, size*0.3); ctx.lineTo(size*0.05, size*0.05); 
    ctx.lineTo(size*0.25, size*0.1); ctx.lineTo(size*0.35, size*0.3); ctx.fill(); ctx.stroke();
    // å³è€³
    ctx.beginPath();
    ctx.moveTo(size*0.9, size*0.3); ctx.lineTo(size*0.95, size*0.05); 
    ctx.lineTo(size*0.75, size*0.1); ctx.lineTo(size*0.65, size*0.3); ctx.fill(); ctx.stroke();

    // è‡‰éƒ¨ä¸»é«” (å¯¬é—Šä¸‹å·´)
    ctx.fillStyle = '#8B5A2B';
    ctx.beginPath();
    ctx.moveTo(size*0.1, size*0.4);
    ctx.bezierCurveTo(-15, size*0.9, size*0.3, size, size/2, size);
    ctx.bezierCurveTo(size*0.7, size, size+15, size*0.9, size*0.9, size*0.4);
    ctx.lineTo(size*0.8, size*0.3);
    ctx.lineTo(size*0.2, size*0.3);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    // é¡é ­
    ctx.beginPath();
    ctx.arc(size/2, size*0.35, size*0.4, Math.PI, 0);
    ctx.fill(); ctx.stroke();

    // æ·±è‰²çœ¼çª©èˆ‡æ†¤æ€’çœ¼ç¥
    ctx.fillStyle = '#3E2723'; // æ·±è‰²èƒŒæ™¯
    ctx.beginPath(); ctx.ellipse(size*0.35, size*0.45, size*0.15, size*0.1, 0.2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(size*0.65, size*0.45, size*0.15, size*0.1, -0.2, 0, Math.PI*2); ctx.fill();
    
    ctx.fillStyle = '#fff'; // ç™½çœ¼çƒ
    ctx.beginPath(); ctx.arc(size*0.35, size*0.45, size*0.08, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(size*0.65, size*0.45, size*0.08, 0, Math.PI*2); ctx.fill();
    
    ctx.fillStyle = '#000'; // ç³å­”
    ctx.beginPath(); ctx.arc(size*0.35, size*0.45, 3, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(size*0.65, size*0.45, 3, 0, Math.PI*2); ctx.fill();

    // é»‘è‰²å¤§é¼»å­
    ctx.beginPath();
    ctx.ellipse(size/2, size*0.6, 10, 6, 0, 0, Math.PI*2); ctx.fill();

    // éœ²å‡ºæ»¿å£ç ç‰™
    ctx.fillStyle = '#fff';
    // å·¦å´å¤§ç‰™
    ctx.beginPath(); ctx.moveTo(size*0.25, size*0.65); ctx.lineTo(size*0.15, size*0.85); ctx.lineTo(size*0.35, size*0.7); ctx.fill(); ctx.stroke();
    // å³å´å¤§ç‰™
    ctx.beginPath(); ctx.moveTo(size*0.75, size*0.65); ctx.lineTo(size*0.85, size*0.85); ctx.lineTo(size*0.65, size*0.7); ctx.fill(); ctx.stroke();
    // ä¸­é–“å°ç‰™
    for(let i=0; i<3; i++) {
        ctx.beginPath(); 
        ctx.moveTo(size*0.4 + i*size*0.05, size*0.7); 
        ctx.lineTo(size*0.42 + i*size*0.05, size*0.78); 
        ctx.lineTo(size*0.45 + i*size*0.05, size*0.7); ctx.fill();
    }

    // åˆºé …åœˆ
    ctx.fillStyle = '#B71C1C';
    ctx.fillRect(size*0.05, size*0.88, size*0.9, size*0.12);
    ctx.fillStyle = '#E0E0E0';
    for(let i=0; i<4; i++) {
        ctx.beginPath();
        ctx.moveTo(size*0.2 + i*size*0.2, size*0.88); ctx.lineTo(size*0.25 + i*size*0.2, size*0.78); ctx.lineTo(size*0.3 + i*size*0.2, size*0.88);
        ctx.fill();
    }
    ctx.restore();
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    player.y = canvas.height * 0.7 - player.h;
}
window.onresize = resize;
resize();

function handleAction(e) {
    if(e) e.preventDefault();
    initAudio();
    if (gameState === 'PLAYING') {
        if (!player.jumped) {
            player.vy = -16;
            player.jumped = true;
            playSfx(523, 'square', 0.1); 
        }
    } else {
        score = 0; scoreEl.innerText = '0';
        obstacles = []; coins = [];
        lastObstacleX = 0; bgmSequence = 0;
        gameState = 'PLAYING';
        overlay.style.display = 'none';
        if (bgmTimer) clearTimeout(bgmTimer);
        playMarioBGM();
    }
}

function update() {
    if (gameState !== 'PLAYING') return;
    bgX -= 4;
    if (bgX <= -canvas.width) bgX = 0;
    player.vy += 0.8; 
    player.y += player.vy;
    let ground = canvas.height * 0.7 - player.h;
    if (player.y > ground) { player.y = ground; player.vy = 0; player.jumped = false; }

    if (canvas.width - lastObstacleX > 500 && Math.random() < 0.008) {
        const types = [
            {icon: 'ğŸŒ', speedMult: 1, type: 'item'}, 
            {icon: 'BULLY', speedMult: 1.6, type: 'dog'}, 
            {icon: 'ğŸ’©', speedMult: 1, type: 'item'}
        ];
        const type = types[Math.floor(Math.random()*3)];
        if(type.type === 'dog') barkEffect();
        obstacles.push({ x: canvas.width, y: canvas.height * 0.7 - 60, icon: type.icon, speed: 5.5 * type.speedMult, type: type.type });
        lastObstacleX = canvas.width;
    }
    if (Math.random() < 0.02) coins.push({ x: canvas.width, y: canvas.height * 0.7 - 140 - Math.random() * 80 });

    obstacles.forEach((o, i) => {
        o.x -= o.speed;
        if (i === obstacles.length - 1) lastObstacleX = o.x;
        if (Math.abs(player.x - o.x) < 45 && Math.abs(player.y - o.y) < 45) {
            gameState = 'GAME_OVER';
            overlay.style.display = 'flex';
            document.querySelector('#msg-box h2').innerText = o.type === 'dog' ? "æ…˜äº†ï¼è¢«æƒ¡éœ¸çŠ¬å’¬äº†" : "éŠæˆ²çµæŸ";
            playSfx(100, 'sawtooth', 0.8, true, 0.2); 
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('bicycleHighScore', highScore);
                highScoreEl.innerText = highScore;
            }
        }
    });

    coins.forEach((c, i) => {
        c.x -= 5.5;
        if (Math.abs(player.x - c.x) < 35 && Math.abs(player.y - c.y) < 35) {
            score += 10; scoreEl.innerText = score;
            playSfx(900, 'sine', 0.08); 
            coins.splice(i, 1);
        }
    });
    obstacles = obstacles.filter(o => o.x > -100);
    coins = coins.filter(c => c.x > -100);
}

function draw() {
    ctx.fillStyle = '#87CEEB'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#2E7D32';
    for (let i = 0; i < 2; i++) {
        let x = bgX + i * canvas.width;
        ctx.beginPath(); ctx.moveTo(x, canvas.height * 0.7);
        ctx.lineTo(x + canvas.width / 2, canvas.height * 0.35);
        ctx.lineTo(x + canvas.width, canvas.height * 0.7); ctx.fill();
    }
    ctx.fillStyle = '#5D4037'; ctx.fillRect(0, canvas.height * 0.7, canvas.width, canvas.height * 0.3);
    ctx.fillStyle = '#689F38'; ctx.fillRect(0, canvas.height * 0.7, canvas.width, 12);

    ctx.save();
    ctx.translate(player.x + 25, player.y + 25);
    ctx.scale(-1, 1); ctx.font = '45px Arial'; ctx.textAlign = 'center';
    ctx.fillText('ğŸš´', 0, 15);
    ctx.restore();

    obstacles.forEach(o => {
        if(o.icon === 'BULLY') {
            drawBullyDog(o.x, o.y - 20, 70);
        } else {
            ctx.font = '35px Arial'; ctx.fillText(o.icon, o.x, o.y + 40);
        }
    });
    ctx.font = '35px Arial';
    coins.forEach(c => ctx.fillText('ğŸª™', c.x, c.y + 25));

    update();
    requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>