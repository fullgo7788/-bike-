<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>è¼ªèƒè‹±é›„ V10 - å¯¬å»£è¦–é‡</title>
    <style>
        :root { height: -webkit-fill-available; }
        body { 
            margin: 0; overflow: hidden; background: #87CEEB; 
            font-family: sans-serif; touch-action: none; user-select: none;
            height: 100vh; height: -webkit-fill-available;
        }
        canvas { display: block; width: 100%; height: 100%; }
        
        #ui { position: absolute; top: 15px; left: 20px; color: #000; font-weight: 900; font-size: 20px; text-shadow: 2px 2px 0 #fff; z-index: 100; pointer-events: none; }
        
        #controls {
            position: absolute; bottom: 25px; left: 0; width: 100%;
            display: flex; justify-content: space-between; padding: 0 50px; box-sizing: border-box; z-index: 150;
        }
        .ctrl-btn {
            width: 85px; height: 85px; background: rgba(0,0,0,0.7);
            border: 3px solid #fff; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 38px; color: #fff;
            backdrop-filter: blur(5px); -webkit-tap-highlight-color: transparent;
        }
        
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; justify-content: center; align-items: center; z-index: 200; }
        #msg-box { background: #fff; padding: 30px; border: 4px solid #000; border-radius: 20px; text-align: center; width: 320px; }
        .btn { display: inline-block; padding: 18px 45px; background: #FFD600; color: #000; border-radius: 50px; font-weight: bold; font-size: 24px; cursor: pointer; border: none; box-shadow: 0 6px 0 #A68B00; }
    </style>
</head>
<body>

<div id="ui">
    <div>åˆ†æ•¸: <span id="score">0</span></div>
    <div style="font-size: 14px;">æœ€é«˜ç´€éŒ„: <span id="highScore">0</span></div>
</div>

<div id="controls">
    <div class="ctrl-btn" id="leftBtn">â–¶</div> 
    <div class="ctrl-btn" id="rightBtn">â–²</div> 
</div>

<div id="overlay">
    <div id="msg-box">
        <h2 id="msg-title">è¼ªèƒè‹±é›„ V10</h2>
        <p style="font-weight: bold; color: #333;">è·¯é¢å·²å„ªåŒ–ï¼Œè¦–é‡æ›´å»£ï¼<br>é»æ“ŠæŒ‰éˆ•å•Ÿå‹•å…¨è¢å¹•</p>
        <button class="btn" id="startBtn">å•Ÿå‹•</button>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const highScoreEl = document.getElementById('highScore');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');

let gameState = 'START'; 
let score = 0;
let highScore = localStorage.getItem('bicycleHighScore') || 0;
highScoreEl.innerText = highScore;

let currentSpeed = 0;
const MAX_SPEED = 6.2;
const ACCEL = 0.16;
const FRICTION = 0.05;
const GRAVITY = 0.52; 
const JUMP_FORCE = -14.2; 

// åˆå§‹ä½ç½®
let player = { x: 200, y: 0, vy: 0, jumped: false };
let obstacles = [];
let coins = [];
let bgX = 0;
let distanceCounter = 0;
let isPressingGo = false;

// é¦¬è·¯ä½”æ¯”èª¿æ•´ (ç”± 0.7 é™è‡³ 0.85ï¼Œä»£è¡¨é¦¬è·¯å¾ç•«é¢ 85% ä½ç½®é–‹å§‹ï¼Œåšåº¦åªå‰© 15%)
const ROAD_Y_RATIO = 0.85;

// éŸ³è¨Šç³»çµ±
let audioCtx = null;
let musicTimer = null;
let melodyStep = 0;
const MELODY = [262, 330, 392, 523, 392, 330, 262, 0, 440, 440, 392, 0];

function initAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playSound(freq, dur, vol, type = 'sine') {
    if(!audioCtx || freq <= 0) return;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    g.gain.setValueAtTime(vol, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
    osc.connect(g).connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + dur);
}

function loopBGM() {
    if (gameState !== 'PLAYING') return;
    let freq = MELODY[melodyStep % MELODY.length];
    playSound(freq, 0.25, 0.12, 'triangle'); 
    melodyStep++;
    let tempo = Math.max(160, 350 - currentSpeed * 25);
    musicTimer = setTimeout(loopBGM, tempo);
}

function toggleFullScreen() {
    if (!document.fullscreenElement && !document.webkitFullscreenElement) {
        if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
        else if (document.documentElement.webkitRequestFullscreen) document.documentElement.webkitRequestFullscreen();
    }
}

const lBtn = document.getElementById('leftBtn');
const rBtn = document.getElementById('rightBtn');
lBtn.addEventListener('touchstart', (e) => { e.preventDefault(); isPressingGo = true; });
lBtn.addEventListener('touchend', () => { isPressingGo = false; });
rBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (!player.jumped && gameState === 'PLAYING') {
        player.vy = JUMP_FORCE;
        player.jumped = true;
        playSound(880, 0.15, 0.08, 'sine');
    }
});

startBtn.onclick = () => {
    initAudio();
    toggleFullScreen();
    score = 0; scoreEl.innerText = '0';
    obstacles = []; coins = []; currentSpeed = 0; melodyStep = 0;
    gameState = 'PLAYING';
    overlay.style.display = 'none';
    setTimeout(() => { resize(); loopBGM(); }, 300);
};

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    player.y = canvas.height * ROAD_Y_RATIO - 50;
}
window.addEventListener('resize', resize);
resize();

function update() {
    if (gameState !== 'PLAYING') return;
    if (isPressingGo) currentSpeed = Math.min(MAX_SPEED, currentSpeed + ACCEL);
    else currentSpeed = Math.max(0, currentSpeed - FRICTION);
    
    bgX -= currentSpeed;
    distanceCounter += currentSpeed;
    if (bgX <= -canvas.width) bgX = 0;
    
    player.vy += GRAVITY;
    player.y += player.vy;
    let groundY = canvas.height * ROAD_Y_RATIO - 50;
    if (player.y > groundY) { player.y = groundY; player.vy = 0; player.jumped = false; }

    if (distanceCounter > 450) { 
        const isCar = Math.random() > 0.4;
        obstacles.push({ x: canvas.width + 100, y: canvas.height * ROAD_Y_RATIO - 60, type: isCar ? 'car' : 'banana', speed: currentSpeed + (isCar ? 2 : 0) });
        if (Math.random() < 0.6) {
            let coinHeight = canvas.height * ROAD_Y_RATIO - 140;
            coins.push({ x: canvas.width + 250, y: coinHeight });
            coins.push({ x: canvas.width + 310, y: coinHeight });
        }
        distanceCounter = 0;
    }

    obstacles.forEach((o, i) => {
        o.x -= o.speed;
        if (Math.abs(player.x - o.x) < 42 && Math.abs(player.y - o.y) < 42) {
            gameState = 'OVER';
            overlay.style.display = 'flex';
            playSound(150, 0.6, 0.15, 'sawtooth'); 
        }
    });

    coins.forEach((c, i) => {
        c.x -= currentSpeed;
        if (Math.abs(player.x - c.x) < 40 && Math.abs(player.y - c.y) < 40) {
            score += 10; scoreEl.innerText = score;
            playSound(1200, 0.1, 0.05, 'sine'); 
            coins.splice(i, 1);
        }
    });

    obstacles = obstacles.filter(o => o.x > -200);
    coins = coins.filter(c => c.x > -100);
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#87CEEB'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // èƒŒæ™¯å±±è„ˆ (é…åˆæ–°è·¯é¢æ¯”ä¾‹)
    ctx.fillStyle = '#2E7D32';
    for(let i=0; i<3; i++) {
        let x = (bgX * 0.4 % canvas.width) + i * canvas.width;
        ctx.beginPath(); 
        ctx.moveTo(x - canvas.width, canvas.height * ROAD_Y_RATIO); 
        ctx.lineTo(x - canvas.width/2, canvas.height * 0.3); // å±±é ‚é«˜åº¦èª¿æ•´
        ctx.lineTo(x, canvas.height * ROAD_Y_RATIO); 
        ctx.fill();
    }
    
    // é¦¬è·¯ (å¤§å¹…æ¸›å°é«˜åº¦)
    ctx.fillStyle = '#444'; 
    ctx.fillRect(0, canvas.height * ROAD_Y_RATIO, canvas.width, canvas.height * (1 - ROAD_Y_RATIO));
    
    // è·¯é¢æ¨™ç·š
    ctx.fillStyle = '#fff';
    for(let i=0; i<15; i++) {
        let lineX = (bgX * 2.2 % 200) + i * 200;
        ctx.fillRect(lineX, canvas.height * (ROAD_Y_RATIO + 0.06), 40, 4);
    }
    
    // è§’è‰²
    ctx.save();
    ctx.translate(player.x + 25, player.y + 25);
    ctx.scale(-1, 1);
    ctx.font = '50px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText('ğŸš´', 0, 0);
    ctx.restore();
    
    // éšœç¤™ç‰©èˆ‡é‡‘å¹£
    obstacles.forEach(o => {
        if(o.type === 'car') {
            ctx.fillStyle = '#D32F2F'; ctx.fillRect(o.x, o.y + 10, 80, 40);
            ctx.fillStyle = '#212121'; ctx.beginPath(); ctx.arc(o.x+20, o.y+50, 10, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(o.x+60, o.y+50, 10, 0, Math.PI*2); ctx.fill();
        } else { ctx.font = '40px Arial'; ctx.fillText('ğŸŒ', o.x + 20, o.y + 35); }
    });
    coins.forEach(c => { ctx.font = '38px Arial'; ctx.fillText('ğŸª™', c.x, c.y + 25); });

    update();
    requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>